../../../../chinese/segmentor/feature.h:   SCORE_TYPE getGlobalScore(const CStringVector* sentence, const CStateItem* item);
../../../../chinese/segmentor/feature.h:   SCORE_TYPE getLocalScore(const CStringVector* sentence, const CStateItem* item, int index);
../../../../chinese/segmentor/acl07.cpp:int CFeatureHandle::getGlobalScore(const CStringVector* sentence, const CStateItem* item){
../../../../chinese/segmentor/acl07.cpp:int CFeatureHandle::getLocalScore(const CStringVector* sentence, const CStateItem* item, int index){
../../../../chinese/segmentor/acl07.cpp:   CStateItem *pGenerator, *pCandidate;
../../../../chinese/segmentor/agenda.cpp:SCORE_TYPE CFeatureHandle::getGlobalScore(const CStringVector* sentence, const CStateItem* item){
../../../../chinese/segmentor/agenda.cpp:SCORE_TYPE CFeatureHandle::getLocalScore(const CStringVector* sentence, const CStateItem* item, int index){
../../../../chinese/segmentor/agenda.cpp:SCORE_TYPE getOrUpdateSeparateScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, SCORE_TYPE amount=0, int round=0){
../../../../chinese/segmentor/agenda.cpp:SCORE_TYPE getOrUpdateAppendScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, int index, SCORE_TYPE amount=0, int round=0){
../../../../chinese/segmentor/agenda.cpp:   static CStateItem temp[MAX_SENTENCE_SIZE+2];
../../../../chinese/segmentor/agenda.cpp:inline void updateScoreVectorForState(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* state, SCORE_TYPE amount, int round) {
../../../../chinese/segmentor/agenda.cpp:   static const CStateItem *temp;
../../../../chinese/segmentor/agenda.cpp:void updateScoreVectorForStates(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* outout, const CStateItem* correct, int round) {
../../../../chinese/segmentor/agenda.cpp:   static CStateItem lattice[(MAX_SENTENCE_SIZE+2)*BEAM_SIZE];
../../../../chinese/segmentor/agenda.cpp:   static CStateItem *lattice_index[MAX_SENTENCE_SIZE+2];
../../../../chinese/segmentor/agenda.cpp:   static const CStateItem *pGenerator, *pBestGen;
../../../../chinese/segmentor/agenda.cpp:   static const CStateItem *correct, *temp;
../../../../chinese/segmentor/agenda.cpp:   static const CStateItem *best[BEAM_SIZE];
../../../../chinese/segmentor/agendachart.cpp:int CFeatureHandle::getGlobalScore(const CStringVector* sentence, const CStateItem* item){
../../../../chinese/segmentor/agendachart.cpp:int CFeatureHandle::getLocalScore(const CStringVector* sentence, const CStateItem* item, int index){
../../../../chinese/segmentor/agendachart.cpp:   const CStateItem *pGenerator, *pCandidate;
../../../../chinese/segmentor/agendachart.cpp:   CStateItem tempState;
../../../../chinese/segmentor/agendachart.cpp:   static CStateItem best_bigram;
../../../../chinese/segmentor/action.cpp:SCORE_TYPE CFeatureHandle::getGlobalScore(const CStringVector* sentence, const CStateItem* item){
../../../../chinese/segmentor/action.cpp:SCORE_TYPE CFeatureHandle::getLocalScore(const CStringVector* sentence, const CStateItem* item, int index){
../../../../chinese/segmentor/action.cpp:SCORE_TYPE getSeparateScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, int index, bool bWordStart){
../../../../chinese/segmentor/action.cpp:SCORE_TYPE getAppendScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, int index, bool bWordStart){
../../../../chinese/segmentor/action.cpp:void updateFullWordScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, int index, SCORE_TYPE amount, int round){
../../../../chinese/segmentor/action.cpp:void updatePartialWordScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, int index, SCORE_TYPE amount, int round){
../../../../chinese/segmentor/action.cpp:   CStateItem temp;
../../../../chinese/segmentor/action.cpp:void updateScoreVector(CSegmentor *segmentor, const CStringVector* sentence, int index, CStateItem* outout, CStateItem* correct, int round) {
../../../../chinese/segmentor/action.cpp:   static CStateItem temp;
../../../../chinese/segmentor/action.cpp:void trace_candidate(CStateItem *pCandidate, const CStringVector &sentence) {
../../../../chinese/segmentor/action.cpp:bool work(CSegmentor *segmentor, const CStringVector &sentence, CRule &rules, CStateItem *pCorrect, int nBest, int round) {
../../../../chinese/segmentor/action.cpp:   CStateItem *pGenerator, *pCandidate;
../../../../chinese/segmentor/action.cpp:   static CStateItem doneWordItems[BEAM_SIZE];          // the allocated cache state items stores the candidates
../../../../chinese/segmentor/action.cpp:   static CStateItem temp_it, candidate;
../../../../chinese/segmentor/action.cpp:   static CStateItem item_correct;
../../../../chinese/segmentor/action.cpp:   CStateItem *pGenerator;
../../../../chinese/segmentor/implementations/agendachart/stateitem.h: * CStateItem - the search state item, representing a segmented sentence 
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:struct CStateItem {
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   CStateItem() { m_lWords = new unsigned long int[MAX_SENTENCE_SIZE]; clear(); }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   ~CStateItem() { delete[] m_lWords; }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   //inline bool operator < (const CStateItem &item) const { return this->m_nScore < item.m_nScore ? true : this->m_nScore == item.m_nScore && this->m_nLength < item.m_nLength; }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   //inline bool operator > (const CStateItem &item) const { return this->m_nScore > item.m_nScore ? true : this->m_nScore == item.m_nScore && this->m_nLength > item.m_nLength; }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->m_nScore < item.m_nScore; }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->m_nScore > item.m_nScore; }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   inline bool operator == (const CStateItem &item) const { 
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   inline bool operator != (const CStateItem &item) const { return ! ((*this) == item); }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   inline void operator = (const CStateItem &item) { copy(&item); }
../../../../chinese/segmentor/implementations/agendachart/stateitem.h:   void copy(const CStateItem *from) {
../../../../chinese/segmentor/implementations/agendachart/stateitem.h://   bool isCompatibleWith(const CStateItem *item) const {
../../../../chinese/segmentor/implementations/agendachart/segmentor_impl.h:      CAgendaChart<CStateItem> m_Chart;
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h: * CStateItem - the search state item, representing a segmented sentence 
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:class CStateItem {
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   const CStateItem *m_prev;
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   CStateItem() : m_nIndex(-1), m_prev(0), m_bAppend(false) { }
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->score < item.score; }
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->score > item.score; }
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   inline bool operator == (const CStateItem &item) const { 
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   inline bool operator != (const CStateItem &item) const { return ! ((*this) == item); }
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   void append(CStateItem *retval) const {
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   void separate(CStateItem *retval) const {
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   inline const CStateItem *prev() const {
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   const CStateItem *item;
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   CScoredAct(const CStateItem *st, bool append, SCORE_TYPE score) : item(st), append(append), score(st->score+score) {}
../../../../chinese/segmentor/implementations/agendaplus/stateitem.h:   void load(const CStateItem *st, bool append, SCORE_TYPE score) {
../../../../chinese/segmentor/implementations/viterbi/segmentor_impl.h:      CStateItem *m_Chart;
../../../../chinese/segmentor/implementations/viterbi/segmentor_impl.h:         m_Chart = new CStateItem[MAX_SENTENCE_SIZE*MAX_SENTENCE_SIZE];
../../../../chinese/segmentor/implementations/agenda/stateitem.h: * CStateItem - the search state item, representing a segmented sentence 
../../../../chinese/segmentor/implementations/agenda/stateitem.h:class CStateItem {
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   const CStateItem *m_prev;
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   CStateItem() : m_nIndex(-1), m_prev(0), m_bAppend(false) { }
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->score < item.score; }
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->score > item.score; }
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   inline bool operator == (const CStateItem &item) const { 
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   inline bool operator != (const CStateItem &item) const { return ! ((*this) == item); }
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   void append(CStateItem *retval) const {
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   void separate(CStateItem *retval) const {
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   inline const CStateItem *prev() const {
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   const CStateItem *item;
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   CScoredAct(const CStateItem *st, bool append, SCORE_TYPE score) : item(st), append(append), score(st->score+score) {}
../../../../chinese/segmentor/implementations/agenda/stateitem.h:   void load(const CStateItem *st, bool append, SCORE_TYPE score) {
../../../../chinese/segmentor/implementations/action/segmentor_impl.h:      CAgendaBeam<CStateItem> *m_Agenda;
../../../../chinese/segmentor/implementations/action/segmentor_impl.h:         m_Agenda = new CAgendaBeam<CStateItem>(BEAM_SIZE);
../../../../chinese/segmentor/implementations/acl07/stateitem.h: * CStateItem - the search state item, representing a segmented sentence 
../../../../chinese/segmentor/implementations/acl07/stateitem.h:struct CStateItem {
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   CStateItem() { m_lWords = new unsigned long int[MAX_SENTENCE_SIZE]; clear(); }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   ~CStateItem() { delete[] m_lWords; }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   //inline bool operator < (const CStateItem &item) const { return this->m_nScore < item.m_nScore ? true : this->m_nScore == item.m_nScore && this->m_nLength < item.m_nLength; }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   //inline bool operator > (const CStateItem &item) const { return this->m_nScore > item.m_nScore ? true : this->m_nScore == item.m_nScore && this->m_nLength > item.m_nLength; }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->m_nScore < item.m_nScore; }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->m_nScore > item.m_nScore; }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   inline bool operator == (const CStateItem &item) const { 
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   inline bool operator != (const CStateItem &item) const { return ! ((*this) == item); }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   inline void operator = (const CStateItem &item) { copy(&item); }
../../../../chinese/segmentor/implementations/acl07/stateitem.h:   void copy(const CStateItem *from) {
../../../../chinese/segmentor/implementations/acl07/stateitem.h://   bool isCompatibleWith(const CStateItem *item) const {
../../../../chinese/segmentor/implementations/acl07/segmentor_impl.h:      CAgendaBeamDoubleIndice<CStateItem> *m_Agenda;
../../../../chinese/segmentor/implementations/acl07/segmentor_impl.h:         m_Agenda = new CAgendaBeamDoubleIndice<CStateItem>(BEAM_SIZE);
../../../../chinese/segmentor/viterbi.cpp:int CFeatureHandle::getGlobalScore(const CStringVector* sentence, const CStateItem* item){
../../../../chinese/segmentor/viterbi.cpp:int CFeatureHandle::getLocalScore(const CStringVector* sentence, const CStateItem* item, int index){
../../../../chinese/segmentor/viterbi.cpp:   CStateItem *pGenerator, *pCandidate;
../../../../chinese/segmentor/viterbi.cpp:   CStateItem temp_item;
../../../../chinese/segmentor/agendaplus.cpp:SCORE_TYPE CFeatureHandle::getGlobalScore(const CStringVector* sentence, const CStateItem* item){
../../../../chinese/segmentor/agendaplus.cpp:SCORE_TYPE CFeatureHandle::getLocalScore(const CStringVector* sentence, const CStateItem* item, int index){
../../../../chinese/segmentor/agendaplus.cpp:SCORE_TYPE getOrUpdateSeparateScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, SCORE_TYPE amount=0, int round=0){
../../../../chinese/segmentor/agendaplus.cpp:SCORE_TYPE getOrUpdateAppendScore(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* item, int index, SCORE_TYPE amount=0, int round=0){
../../../../chinese/segmentor/agendaplus.cpp:   static CStateItem temp[MAX_SENTENCE_SIZE+2];
../../../../chinese/segmentor/agendaplus.cpp:inline void updateScoreVectorForState(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* state, SCORE_TYPE amount, int round) {
../../../../chinese/segmentor/agendaplus.cpp:   static const CStateItem *temp;
../../../../chinese/segmentor/agendaplus.cpp:void updateScoreVectorForStates(CSegmentor *segmentor, const CStringVector* sentence, const CStateItem* outout, const CStateItem* correct, int round) {
../../../../chinese/segmentor/agendaplus.cpp:   static CStateItem lattice[(MAX_SENTENCE_SIZE+2)*BEAM_SIZE];
../../../../chinese/segmentor/agendaplus.cpp:   static CStateItem *lattice_index[MAX_SENTENCE_SIZE+2];
../../../../chinese/segmentor/agendaplus.cpp:   static const CStateItem *pGenerator, *pBestGen;
../../../../chinese/segmentor/agendaplus.cpp:   static const CStateItem *correct, *temp;
../../../../chinese/segmentor/agendaplus.cpp:   static const CStateItem *best[BEAM_SIZE];
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:SCORE_TYPE CTagger::getOrUpdateLocalScore( const CStringVector *sentence, const CStateItem *item, unsigned long index, SCORE_TYPE amount, unsigned long round ) {
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:inline void buildStateItem(const CStringVector *raw, const CTwoStringVector *tagged, CStateItem *item) {
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:   static CStateItem item ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:   static CStateItem item ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:void generate(const CStateItem *stateItem, CStringVector *sentence, CTagger *tagger, CTwoStringVector *vReturn) {
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:   const CStateItem * generator_item ; 
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:   CStateItem *candidate_item , tempState , maxState ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp.bak:   static CStateItem best_bigram[ CTag::COUNT ] ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:SCORE_TYPE CTagger::getOrUpdateLocalScore( const CStringVector *sentence, const CStateItem *item, unsigned long index, SCORE_TYPE amount, unsigned long round ) {
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:inline void buildStateItem(const CStringVector *raw, const CTwoStringVector *tagged, CStateItem *item) {
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:   static CStateItem item ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:   static CStateItem item ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:void generate(const CStateItem *stateItem, CStringVector *sentence, CTagger *tagger, CTwoStringVector *vReturn) {
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:   const CStateItem * generator_item ; 
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:   CStateItem *candidate_item , tempState , maxState ;
../../../../chinese/tagger/implementations/agendachart/tagger.cpp:   static CStateItem best_bigram[ 1<<CTag::SIZE ] ; 
../../../../chinese/tagger/implementations/agendachart/stateitem.h: * CStateItem - the search state item, representing a tagged sentence 
../../../../chinese/tagger/implementations/agendachart/stateitem.h:class CStateItem {
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   CStateItem() { 
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   ~CStateItem() { 
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   CStateItem(CStateItem& item) { 
../../../../chinese/tagger/implementations/agendachart/stateitem.h:      THROW("CStateItem does not support copy constructor!"); 
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->score < item.score ? true : false; /*this->score == item.score && this->m_nLength < item.m_nLength; */}
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->score > item.score ? true : false; /*this->score == item.score && this->m_nLength > item.m_nLength; */}
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   bool operator == (const CStateItem &item) const {
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   bool operator != (const CStateItem &item) const {
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   void copy(const CStateItem *from) {
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   void operator = (const CStateItem &from) {
../../../../chinese/tagger/implementations/agendachart/stateitem.h:   bool isCompatibleWith(const CStateItem *item) const {
../../../../chinese/tagger/implementations/agendachart/tagger.h:   CAgendaChart<tagger::CStateItem> m_Chart;
../../../../chinese/tagger/implementations/agendachart/tagger.h:   tagger::SCORE_TYPE getOrUpdateLocalScore(const CStringVector *tagged, const tagger::CStateItem *item, unsigned long index, tagger::SCORE_TYPE amount=0, unsigned long round=0);
../../../../chinese/tagger/implementations/agendanew/stateitem.h: * CStateItem - the search state item, representing a tagged sentence 
../../../../chinese/tagger/implementations/agendanew/stateitem.h:class CStateItem {
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   CStateItem() { 
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   ~CStateItem() { 
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   CStateItem(CStateItem& item) { 
../../../../chinese/tagger/implementations/agendanew/stateitem.h:      THROW("CStateItem does not support copy constructor!"); 
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->score < item.score ? true : false; /*this->score == item.score && this->m_nLength < item.m_nLength; */}
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->score > item.score ? true : false; /*this->score == item.score && this->m_nLength > item.m_nLength; */}
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   bool operator == (const CStateItem &item) const {
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   bool operator != (const CStateItem &item) const {
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   void copy(const CStateItem *from) {
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   void operator = (const CStateItem &from) {
../../../../chinese/tagger/implementations/agendanew/stateitem.h:   bool isCompatibleWith(const CStateItem *item) const {
../../../../chinese/tagger/implementations/agendanew/tagger.h:class CSubStateItem : public CStateItem {
../../../../chinese/tagger/implementations/agenda/stateitem.h: * CStateItem - the search state item, representing a tagged sentence 
../../../../chinese/tagger/implementations/agenda/stateitem.h:class CStateItem {
../../../../chinese/tagger/implementations/agenda/stateitem.h:   CStateItem() { 
../../../../chinese/tagger/implementations/agenda/stateitem.h:   ~CStateItem() { 
../../../../chinese/tagger/implementations/agenda/stateitem.h:   CStateItem(CStateItem& item) { 
../../../../chinese/tagger/implementations/agenda/stateitem.h:      THROW("CStateItem does not support copy constructor!"); 
../../../../chinese/tagger/implementations/agenda/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->score < item.score ? true : false; /*this->score == item.score && this->m_nLength < item.m_nLength; */}
../../../../chinese/tagger/implementations/agenda/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->score > item.score ? true : false; /*this->score == item.score && this->m_nLength > item.m_nLength; */}
../../../../chinese/tagger/implementations/agenda/stateitem.h:   bool operator == (const CStateItem &item) const {
../../../../chinese/tagger/implementations/agenda/stateitem.h:   bool operator != (const CStateItem &item) const {
../../../../chinese/tagger/implementations/agenda/stateitem.h:   void copy(const CStateItem *from) {
../../../../chinese/tagger/implementations/agenda/stateitem.h:   void operator = (const CStateItem &from) {
../../../../chinese/tagger/implementations/agenda/stateitem.h:   bool isCompatibleWith(const CStateItem *item) const {
../../../../chinese/tagger/implementations/agenda/tagger.h:class CSubStateItem : public CStateItem {
../../../../chinese/tagger/implementations/segmented/tagger.cpp:SCORE_TYPE CTagger::getLocalScore( const CStringVector * sentence, CStateItem * item , unsigned long index ) {
../../../../chinese/tagger/implementations/segmented/tagger.cpp:void generate(const CStateItem *stateItem, CStringVector *sentence, CTwoStringVector *vReturn) {
../../../../chinese/tagger/implementations/segmented/tagger.cpp:   tagger::CStateItem *pGenerator;
../../../../chinese/tagger/implementations/segmented/tagger.cpp:   tagger::CStateItem *pCandidate;
../../../../chinese/tagger/implementations/segmented/tagger.cpp:   static CStateItem best_bigram[CTag::COUNT][CTag::COUNT];
../../../../chinese/tagger/implementations/segmented/stateitem.h: * CStateItem - the search state item, representing a tagged sentence 
../../../../chinese/tagger/implementations/segmented/stateitem.h:class CStateItem {
../../../../chinese/tagger/implementations/segmented/stateitem.h:   CStateItem() { 
../../../../chinese/tagger/implementations/segmented/stateitem.h:   ~CStateItem() { 
../../../../chinese/tagger/implementations/segmented/stateitem.h:   CStateItem(CStateItem& item) { 
../../../../chinese/tagger/implementations/segmented/stateitem.h:      THROW("CStateItem does not support copy constructor!"); 
../../../../chinese/tagger/implementations/segmented/stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->score < item.score ? true : false; /*this->score == item.score && this->m_nLength < item.m_nLength; */}
../../../../chinese/tagger/implementations/segmented/stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->score > item.score ? true : false; /*this->score == item.score && this->m_nLength > item.m_nLength; */}
../../../../chinese/tagger/implementations/segmented/stateitem.h:   bool operator == (const CStateItem &item) const {
../../../../chinese/tagger/implementations/segmented/stateitem.h:   bool operator != (const CStateItem &item) const {
../../../../chinese/tagger/implementations/segmented/stateitem.h:   void copy(const CStateItem *from) {
../../../../chinese/tagger/implementations/segmented/stateitem.h:   void operator = (const CStateItem &from) {
../../../../chinese/tagger/implementations/segmented/stateitem.h:   bool isCompatibleWith(const CStateItem *item) const {
../../../../chinese/tagger/implementations/segmented/tagger.h:   CAgendaBeam<tagger::CStateItem> m_Agenda;
../../../../chinese/tagger/implementations/segmented/tagger.h:   tagger::SCORE_TYPE getLocalScore(const CStringVector*, tagger::CStateItem*, unsigned long);
../../../../common/depparser/implementations/punct/state.h: * CStateItem - the search state item, representing a partial
../../../../common/depparser/implementations/punct/state.h:class CStateItem {
../../../../common/depparser/implementations/punct/state.h:   CStateItem() { clear(); }
../../../../common/depparser/implementations/punct/state.h:   ~CStateItem() { }
../../../../common/depparser/implementations/punct/state.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../common/depparser/implementations/punct/state.h:   inline bool operator < (const CStateItem &item) const { return score() < item.score(); }
../../../../common/depparser/implementations/punct/state.h:   inline bool operator > (const CStateItem &item) const { return score() > item.score(); }
../../../../common/depparser/implementations/punct/state.h:   inline bool operator == (const CStateItem &item) const {
../../../../common/depparser/implementations/punct/state.h:   inline bool operator != (const CStateItem &item) const {
../../../../common/depparser/implementations/punct/state.h:   void operator = ( const CStateItem &item ) {
../../../../common/depparser/implementations/punct/state.h:   unsigned long FollowMove( const CStateItem *item ) {
../../../../common/depparser/implementations/punct/depparser.h:   CAgendaBeam<depparser::CStateItem> *m_Agenda;
../../../../common/depparser/implementations/punct/depparser.h:      m_Agenda = new CAgendaBeam<depparser::CStateItem>(depparser::AGENDA_SIZE);
../../../../common/depparser/implementations/punct/depparser.h:   inline depparser::SCORE_TYPE getOrUpdateStackScore( const depparser::CStateItem *item, const unsigned long &action, depparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/depparser/implementations/punct/depparser.h:   void updateScoresForStates( const depparser::CStateItem *outout , const depparser::CStateItem *correct , 
../../../../common/depparser/implementations/punct/depparser.h:   inline void updateScoreForState( const depparser::CStateItem *outout , const depparser::SCORE_TYPE &amount ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void reduce( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void shift( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void arcleft( depparser::CStateItem *item, const unsigned long &label ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void arcright( depparser::CStateItem *item, const unsigned long &label ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void arcleft( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void arcright( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/punct/depparser.h:   inline void poproot( depparser::CStateItem *item ) ;  
../../../../common/depparser/implementations/punct/depparser.cpp:inline SCORE_TYPE CDepParser::getOrUpdateStackScore( const CStateItem *item, const unsigned long &action, SCORE_TYPE amount , int round ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   static CStateItem item, temp;
../../../../common/depparser/implementations/punct/depparser.cpp:      switch ( CStateItem::getAction(action) ) {
../../../../common/depparser/implementations/punct/depparser.cpp:      case CStateItem::SHIFT:
../../../../common/depparser/implementations/punct/depparser.cpp:      case CStateItem::REDUCE:
../../../../common/depparser/implementations/punct/depparser.cpp:      case CStateItem::ARC_LEFT:
../../../../common/depparser/implementations/punct/depparser.cpp:         arcleft( &temp, CStateItem::getLabel(action) );
../../../../common/depparser/implementations/punct/depparser.cpp:      case CStateItem::ARC_RIGHT:
../../../../common/depparser/implementations/punct/depparser.cpp:         arcright( &temp, CStateItem::getLabel(action) );
../../../../common/depparser/implementations/punct/depparser.cpp:      case CStateItem::POP_ROOT:
../../../../common/depparser/implementations/punct/depparser.cpp:inline int find_information( const CStateItem *item, int *stack ) {
../../../../common/depparser/implementations/punct/depparser.cpp:      stack[i] = CStateItem::OFF_STACK;
../../../../common/depparser/implementations/punct/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_SHIFT;
../../../../common/depparser/implementations/punct/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_ARCRIGHT;
../../../../common/depparser/implementations/punct/depparser.cpp:   CStateItem state;
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::updateScoreForState( const CStateItem *outout , const SCORE_TYPE &amount ) {
../../../../common/depparser/implementations/punct/depparser.cpp:         if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/punct/depparser.cpp:      if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   static CStateItem item;
../../../../common/depparser/implementations/punct/depparser.cpp:      TRACE_WORD(CStateItem::printAction(action));
../../../../common/depparser/implementations/punct/depparser.cpp:      if ( CStateItem::getAction(action) != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/punct/depparser.cpp:      if ( action != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/punct/depparser.cpp:         if ( CStateItem::getLabel(action) )
../../../../common/depparser/implementations/punct/depparser.cpp:            getOrUpdateStackScore( &item, CStateItem::removeLabelFromEncodedAction(action), amount, m_nTrainingRound );
../../../../common/depparser/implementations/punct/depparser.cpp:void CDepParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct , SCORE_TYPE amount_add, SCORE_TYPE amount_subtract ) {
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::reduce( CStateItem *item ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::REDUCE, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::REDUCE );
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item, const unsigned long &label ) {
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_LEFT, label) );
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_LEFT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_LEFT );
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::arcright( CStateItem *item, const unsigned long &label ) {
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::arcright( CStateItem *item ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_RIGHT, label) );
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_RIGHT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_RIGHT );
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::shift( CStateItem *item ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::SHIFT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/punct/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::SHIFT );
../../../../common/depparser/implementations/punct/depparser.cpp:inline void CDepParser::poproot( CStateItem *item ) {
../../../../common/depparser/implementations/punct/depparser.cpp:   const CStateItem *pGenerator ;
../../../../common/depparser/implementations/punct/depparser.cpp:   static CStateItem pCandidate ;
../../../../common/depparser/implementations/punct/depparser.cpp:   static CStateItem correctState ;
../../../../common/depparser/implementations/noisy/state.h: * CStateItem - the search state item, representing a partial
../../../../common/depparser/implementations/noisy/state.h:class CStateItem {
../../../../common/depparser/implementations/noisy/state.h:   CStateItem() { clear(); }
../../../../common/depparser/implementations/noisy/state.h:   ~CStateItem() { }
../../../../common/depparser/implementations/noisy/state.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../common/depparser/implementations/noisy/state.h:   inline bool operator < (const CStateItem &item) const { return score() < item.score(); }
../../../../common/depparser/implementations/noisy/state.h:   inline bool operator > (const CStateItem &item) const { return score() > item.score(); }
../../../../common/depparser/implementations/noisy/state.h:   inline bool operator == (const CStateItem &item) const {
../../../../common/depparser/implementations/noisy/state.h:   inline bool operator != (const CStateItem &item) const {
../../../../common/depparser/implementations/noisy/state.h:   void operator = ( const CStateItem &item ) {
../../../../common/depparser/implementations/noisy/state.h:   unsigned long FollowMove( const CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.h:   CAgendaBeam<depparser::CStateItem> *m_Agenda;
../../../../common/depparser/implementations/noisy/depparser.h:      m_Agenda = new CAgendaBeam<depparser::CStateItem>(depparser::AGENDA_SIZE);
../../../../common/depparser/implementations/noisy/depparser.h:   inline depparser::SCORE_TYPE getOrUpdateStackScore( const depparser::CStateItem *item, const unsigned long &action, depparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/depparser/implementations/noisy/depparser.h:   void updateScoresForStates( const depparser::CStateItem *outout , const depparser::CStateItem *correct , 
../../../../common/depparser/implementations/noisy/depparser.h:   inline void updateScoreForState( const depparser::CStateItem *outout , const depparser::SCORE_TYPE &amount ) ;
../../../../common/depparser/implementations/noisy/depparser.h:   inline void reduce( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/noisy/depparser.h:   inline void popfrag( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/noisy/depparser.h:   inline void shift( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/noisy/depparser.h:   inline void arcleft( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/noisy/depparser.h:   inline void arcright( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/noisy/depparser.h:   inline void poproot( depparser::CStateItem *item ) ;  
../../../../common/depparser/implementations/noisy/depparser.cpp:inline SCORE_TYPE CDepParser::getOrUpdateStackScore( const CStateItem *item, const unsigned long &action, SCORE_TYPE amount , int round ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   static CStateItem item, temp;
../../../../common/depparser/implementations/noisy/depparser.cpp:      case CStateItem::SHIFT:
../../../../common/depparser/implementations/noisy/depparser.cpp:      case CStateItem::REDUCE:
../../../../common/depparser/implementations/noisy/depparser.cpp:      case CStateItem::ARC_LEFT:
../../../../common/depparser/implementations/noisy/depparser.cpp:      case CStateItem::ARC_RIGHT:
../../../../common/depparser/implementations/noisy/depparser.cpp:      case CStateItem::POP_ROOT:
../../../../common/depparser/implementations/noisy/depparser.cpp:      case CStateItem::POP_FRAG:
../../../../common/depparser/implementations/noisy/depparser.cpp:inline int find_information( const CStateItem *item, int *stack ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:      stack[i] = CStateItem::OFF_STACK;
../../../../common/depparser/implementations/noisy/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_SHIFT;
../../../../common/depparser/implementations/noisy/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_ARCRIGHT;
../../../../common/depparser/implementations/noisy/depparser.cpp:   CStateItem state;
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::updateScoreForState( const CStateItem *outout , const SCORE_TYPE &amount ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:         if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:      if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   static CStateItem item;
../../../../common/depparser/implementations/noisy/depparser.cpp:      if ( CStateItem::getAction(action) != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:      if ( action != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:         if ( CStateItem::getLabel(action) )
../../../../common/depparser/implementations/noisy/depparser.cpp:            getOrUpdateStackScore( &item, CStateItem::removeLabelFromEncodedAction(action), amount, m_nTrainingRound );
../../../../common/depparser/implementations/noisy/depparser.cpp:void CDepParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct , SCORE_TYPE amount_add, SCORE_TYPE amount_subtract ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::reduce( CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::REDUCE );
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::popfrag( CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::POP_FRAG );
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_LEFT );
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::arcright( CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_RIGHT );
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::shift( CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::SHIFT );
../../../../common/depparser/implementations/noisy/depparser.cpp:inline void CDepParser::poproot( CStateItem *item ) {
../../../../common/depparser/implementations/noisy/depparser.cpp:   const CStateItem *pGenerator ;
../../../../common/depparser/implementations/noisy/depparser.cpp:   CStateItem pCandidate ;
../../../../common/depparser/implementations/noisy/depparser.cpp:   static CStateItem correctState ;
../../../../common/depparser/implementations/uppsala/state.h: * CStateItem - the search state item, representing a partial
../../../../common/depparser/implementations/uppsala/state.h:class CStateItem {
../../../../common/depparser/implementations/uppsala/state.h:   CStateItem() { clear(); }
../../../../common/depparser/implementations/uppsala/state.h:   ~CStateItem() { }
../../../../common/depparser/implementations/uppsala/state.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../common/depparser/implementations/uppsala/state.h:   inline bool operator < (const CStateItem &item) const { return score() < item.score(); }
../../../../common/depparser/implementations/uppsala/state.h:   inline bool operator > (const CStateItem &item) const { return score() > item.score(); }
../../../../common/depparser/implementations/uppsala/state.h:   inline bool operator == (const CStateItem &item) const {
../../../../common/depparser/implementations/uppsala/state.h:   inline bool operator != (const CStateItem &item) const {
../../../../common/depparser/implementations/uppsala/state.h:   void operator = ( const CStateItem &item ) {
../../../../common/depparser/implementations/uppsala/state.h:   unsigned long FollowMove( const CStateItem *item ) {
../../../../common/depparser/implementations/uppsala/depparser.h:   CAgendaBeam<depparser::CStateItem> *m_Agenda;
../../../../common/depparser/implementations/uppsala/depparser.h:      m_Agenda = new CAgendaBeam<depparser::CStateItem>(depparser::AGENDA_SIZE);
../../../../common/depparser/implementations/uppsala/depparser.h:   inline depparser::SCORE_TYPE getOrUpdateStackScore( const depparser::CStateItem *item, const unsigned long &action, depparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/depparser/implementations/uppsala/depparser.h:   void updateScoresForStates( const depparser::CStateItem *outout , const depparser::CStateItem *correct , 
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void updateScoreForState( const depparser::CStateItem *outout , const depparser::SCORE_TYPE &amount ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void reduce( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void shift( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void arcleft( depparser::CStateItem *item, const unsigned long &label ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void arcright( depparser::CStateItem *item, const unsigned long &label ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void arcleft( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void arcright( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/uppsala/depparser.h:   inline void poproot( depparser::CStateItem *item ) ;  
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline SCORE_TYPE CDepParser::getOrUpdateStackScore( const CStateItem *item, const unsigned long &action, SCORE_TYPE amount , int round ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   static CStateItem item, temp;
../../../../common/depparser/implementations/uppsala/depparser.cpp:      switch ( CStateItem::getAction(action) ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:      case CStateItem::SHIFT:
../../../../common/depparser/implementations/uppsala/depparser.cpp:      case CStateItem::REDUCE:
../../../../common/depparser/implementations/uppsala/depparser.cpp:      case CStateItem::ARC_LEFT:
../../../../common/depparser/implementations/uppsala/depparser.cpp:         arcleft( &temp, CStateItem::getLabel(action) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:      case CStateItem::ARC_RIGHT:
../../../../common/depparser/implementations/uppsala/depparser.cpp:         arcright( &temp, CStateItem::getLabel(action) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:      case CStateItem::POP_ROOT:
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void find_information( const CStateItem *item, int *stack ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:      stack[i] = CStateItem::OFF_STACK;
../../../../common/depparser/implementations/uppsala/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_SHIFT;
../../../../common/depparser/implementations/uppsala/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_ARCRIGHT;
../../../../common/depparser/implementations/uppsala/depparser.cpp:   CStateItem state;
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::updateScoreForState( const CStateItem *outout , const SCORE_TYPE &amount ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:         if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:      if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   static CStateItem item;
../../../../common/depparser/implementations/uppsala/depparser.cpp:      if ( CStateItem::getAction(action) != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:      if ( action != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:         if ( CStateItem::getLabel(action) )
../../../../common/depparser/implementations/uppsala/depparser.cpp:            getOrUpdateStackScore( &item, CStateItem::removeLabelFromEncodedAction(action), amount, m_nTrainingRound );
../../../../common/depparser/implementations/uppsala/depparser.cpp:void CDepParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct , SCORE_TYPE amount_add, SCORE_TYPE amount_subtract ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::reduce( CStateItem *item ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::REDUCE, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::REDUCE );
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item, const unsigned long &label ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_LEFT, label) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_LEFT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_LEFT );
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::arcright( CStateItem *item, const unsigned long &label ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::arcright( CStateItem *item ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_RIGHT, label) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_RIGHT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_RIGHT );
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::shift( CStateItem *item ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::SHIFT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/uppsala/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::SHIFT );
../../../../common/depparser/implementations/uppsala/depparser.cpp:inline void CDepParser::poproot( CStateItem *item ) {
../../../../common/depparser/implementations/uppsala/depparser.cpp:   const CStateItem *pGenerator ;
../../../../common/depparser/implementations/uppsala/depparser.cpp:   static CStateItem pCandidate ;
../../../../common/depparser/implementations/uppsala/depparser.cpp:   static CStateItem correctState ;
../../../../common/depparser/implementations/covington/state.h: * CStateItem - the search state item
../../../../common/depparser/implementations/covington/state.h:class CStateItem {
../../../../common/depparser/implementations/covington/state.h:   CStateItem() { clear(); }
../../../../common/depparser/implementations/covington/state.h:   virtual ~CStateItem() { }
../../../../common/depparser/implementations/covington/state.h:   CStateItem(CStateItem& item) { THROW("depparser::CStateItem does not support copy constructor!"); }
../../../../common/depparser/implementations/covington/state.h:   void operator = ( const CStateItem &item ) {
../../../../common/depparser/implementations/covington/state.h:      THROW("depparser::CStateItem findPreviousLinkPoint: the code should not have reached here");
../../../../common/depparser/implementations/covington/state.h:   inline bool operator < (const CStateItem &item) const { return const_score() < item.const_score(); }
../../../../common/depparser/implementations/covington/state.h:   inline bool operator > (const CStateItem &item) const { return const_score() > item.const_score(); }
../../../../common/depparser/implementations/covington/state.h:   inline bool operator == (const CStateItem &item) const {
../../../../common/depparser/implementations/covington/state.h:   inline bool operator != (const CStateItem &item) const {
../../../../common/depparser/implementations/covington/state.h:inline std::ostream & operator << (std::ostream &os, const CStateItem &item) {
../../../../common/depparser/implementations/covington/depparser.h:   CAgendaBeam<depparser::CStateItem> *m_Agenda;
../../../../common/depparser/implementations/covington/depparser.h:      m_Agenda = new CAgendaBeam<depparser::CStateItem>(depparser::AGENDA_SIZE);
../../../../common/depparser/implementations/covington/depparser.h:   inline void addLink( depparser::CStateItem *item , const int &head , const int &dep ) ;
../../../../common/depparser/implementations/covington/depparser.h:   inline void finishWord( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/covington/depparser.h:   inline void finishWordOnTheLeft( depparser::CStateItem *item , const int &index ) ;
../../../../common/depparser/implementations/covington/depparser.h:   inline void finishWordOnTheRight( depparser::CStateItem *item , const int &index ) ;
../../../../common/depparser/implementations/covington/depparser.h:   inline void finishSentence( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/covington/depparser.h:   inline depparser::SCORE_TYPE getOrUpdateArcScore(const depparser::CStateItem *item, const int &head_index, const int &dep_index, depparser::SCORE_TYPE amount=0, int round=0 ) ;
../../../../common/depparser/implementations/covington/depparser.h:   inline depparser::SCORE_TYPE getOrUpdateArityScore(const depparser::CStateItem *item, const int &word_index, const int &arity_direction, depparser::SCORE_TYPE amount=0, int round=0 ) ;
../../../../common/depparser/implementations/covington/depparser.h:   void updateScoresForStates(const depparser::CStateItem *outout , const depparser::CStateItem *correct , 
../../../../common/depparser/implementations/covington/depparser.h:   inline void updateScoreForState(const depparser::CStateItem *outout , const bool &bCompleteSentence , 
../../../../common/depparser/implementations/covington/depparser.cpp:SCORE_TYPE CDepParser::getOrUpdateArcScore( const CStateItem *item, const int &head_index , const int &dep_index, SCORE_TYPE amount, int round ) {
../../../../common/depparser/implementations/covington/depparser.cpp:inline SCORE_TYPE CDepParser::getOrUpdateArityScore( const CStateItem *item, const int &word_index, const int &arity_direction, SCORE_TYPE amount, int round ) {
../../../../common/depparser/implementations/covington/depparser.cpp:inline void CDepParser::updateScoreForState( const CStateItem *outout , const bool &bCompleteSentence , 
../../../../common/depparser/implementations/covington/depparser.cpp:   static CStateItem item;
../../../../common/depparser/implementations/covington/depparser.cpp:void CDepParser::updateScoresForStates( const CStateItem *outout, const CStateItem *correct, const bool &bCompleteSentence ) {
../../../../common/depparser/implementations/covington/depparser.cpp:void CDepParser::addLink( CStateItem *item, const int &head, const int &dep ) {
../../../../common/depparser/implementations/covington/depparser.cpp:void CDepParser::finishWordOnTheLeft( CStateItem *item, const int &index ) {
../../../../common/depparser/implementations/covington/depparser.cpp:void CDepParser::finishWordOnTheRight( CStateItem *item, const int &index ) {
../../../../common/depparser/implementations/covington/depparser.cpp:void CDepParser::finishWord( CStateItem *candidate ) {
../../../../common/depparser/implementations/covington/depparser.cpp:void CDepParser::finishSentence( CStateItem *candidate ) {
../../../../common/depparser/implementations/covington/depparser.cpp:   const CStateItem *pGenerator ;
../../../../common/depparser/implementations/covington/depparser.cpp:   CStateItem *pCandidate ;
../../../../common/depparser/implementations/covington/depparser.cpp:   CStateItem temp ;
../../../../common/depparser/implementations/covington/depparser.cpp:   static CStateItem correctState ;
../../../../common/depparser/implementations/arceager/state.h: * CStateItem - the search state item, representing a partial
../../../../common/depparser/implementations/arceager/state.h:class CStateItem {
../../../../common/depparser/implementations/arceager/state.h:   CStateItem(const std::vector < CTaggedWord<CTag, TAG_SEPARATOR> >*cache=0) : m_lCache(cache) { clear(); }
../../../../common/depparser/implementations/arceager/state.h:   ~CStateItem() { }
../../../../common/depparser/implementations/arceager/state.h:   CStateItem(CStateItem& item) : m_lCache(0) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../common/depparser/implementations/arceager/state.h:   inline bool operator < (const CStateItem &item) const { return score < item.score; }
../../../../common/depparser/implementations/arceager/state.h:   inline bool operator > (const CStateItem &item) const { return score > item.score; }
../../../../common/depparser/implementations/arceager/state.h:   inline bool operator == (const CStateItem &item) const {
../../../../common/depparser/implementations/arceager/state.h:   inline bool operator != (const CStateItem &item) const {
../../../../common/depparser/implementations/arceager/state.h:   void operator = ( const CStateItem &item ) {
../../../../common/depparser/implementations/arceager/state.h:   unsigned FollowMove( const CStateItem *item ) {
../../../../common/depparser/implementations/arceager/depparser.h:   CAgendaBeam<depparser::CStateItem> *m_Agenda;
../../../../common/depparser/implementations/arceager/depparser.h:      m_Agenda = new CAgendaBeam<depparser::CStateItem>(depparser::AGENDA_SIZE);
../../../../common/depparser/implementations/arceager/depparser.h:   inline void getOrUpdateStackScore( const depparser::CStateItem *item, CPackedScoreType<depparser::SCORE_TYPE, depparser::action::MAX> &retval, const unsigned &action, depparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/depparser/implementations/arceager/depparser.h:   void updateScoresForStates( const depparser::CStateItem *outout , const depparser::CStateItem *correct , depparser::SCORE_TYPE amount_add , depparser::SCORE_TYPE amount_subtract ) ;
../../../../common/depparser/implementations/arceager/depparser.h:   inline void updateScoreForState( const depparser::CStateItem &from, const depparser::CStateItem *outout , const depparser::SCORE_TYPE &amount ) ;
../../../../common/depparser/implementations/arceager/depparser.h:   inline void reduce( const depparser::CStateItem *item, const CPackedScoreType<depparser::SCORE_TYPE, depparser::action::MAX> &scores ) ;
../../../../common/depparser/implementations/arceager/depparser.h:   inline void shift( const depparser::CStateItem *item, const CPackedScoreType<depparser::SCORE_TYPE, depparser::action::MAX> &scores) ;
../../../../common/depparser/implementations/arceager/depparser.h:   inline void arcleft( const depparser::CStateItem *item, const CPackedScoreType<depparser::SCORE_TYPE, depparser::action::MAX> &scores) ;
../../../../common/depparser/implementations/arceager/depparser.h:   inline void arcright( const depparser::CStateItem *item, const CPackedScoreType<depparser::SCORE_TYPE, depparser::action::MAX> &scores) ;
../../../../common/depparser/implementations/arceager/depparser.h:   inline void poproot( const depparser::CStateItem *item, const CPackedScoreType<depparser::SCORE_TYPE, depparser::action::MAX> &scores) ;  
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::getOrUpdateStackScore( const CStateItem *item, CPackedScoreType<SCORE_TYPE, action::MAX> &retval, const unsigned &action, SCORE_TYPE amount , int round ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::updateScoreForState( const CStateItem &from, const CStateItem *outout , const SCORE_TYPE &amount ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:   static CStateItem item(&m_lCache);
../../../../common/depparser/implementations/arceager/depparser.cpp:void CDepParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct , SCORE_TYPE amount_add, SCORE_TYPE amount_subtract ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:   static CStateItem item(&m_lCache);
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::reduce( const CStateItem *item, const CPackedScoreType<SCORE_TYPE, action::MAX> &scores ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::arcleft( const CStateItem *item, const CPackedScoreType<SCORE_TYPE, action::MAX> &scores ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::arcright( const CStateItem *item, const CPackedScoreType<SCORE_TYPE, action::MAX> &scores ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::shift( const CStateItem *item, const CPackedScoreType<SCORE_TYPE, action::MAX> &scores ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:inline void CDepParser::poproot( const CStateItem *item, const CPackedScoreType<SCORE_TYPE, action::MAX> &scores ) {
../../../../common/depparser/implementations/arceager/depparser.cpp:   const CStateItem *pGenerator ;
../../../../common/depparser/implementations/arceager/depparser.cpp:   static CStateItem pCandidate(&m_lCache) ;
../../../../common/depparser/implementations/arceager/depparser.cpp:   static CStateItem correctState(&m_lCache) ;
../../../../common/depparser/implementations/emnlp08/state.h: * CStateItem - the search state item, representing a partial
../../../../common/depparser/implementations/emnlp08/state.h:class CStateItem {
../../../../common/depparser/implementations/emnlp08/state.h:   CStateItem() { clear(); }
../../../../common/depparser/implementations/emnlp08/state.h:   ~CStateItem() { }
../../../../common/depparser/implementations/emnlp08/state.h:   CStateItem(CStateItem& item) { std::cerr<<"CStateItem does not support copy constructor!"; std::cerr.flush(); assert(1==0); }
../../../../common/depparser/implementations/emnlp08/state.h:   inline bool operator < (const CStateItem &item) const { return score() < item.score(); }
../../../../common/depparser/implementations/emnlp08/state.h:   inline bool operator > (const CStateItem &item) const { return score() > item.score(); }
../../../../common/depparser/implementations/emnlp08/state.h:   inline bool operator == (const CStateItem &item) const {
../../../../common/depparser/implementations/emnlp08/state.h:   inline bool operator != (const CStateItem &item) const {
../../../../common/depparser/implementations/emnlp08/state.h:   void operator = ( const CStateItem &item ) {
../../../../common/depparser/implementations/emnlp08/state.h:   unsigned long FollowMove( const CStateItem *item ) {
../../../../common/depparser/implementations/emnlp08/depparser.h:   CAgendaBeam<depparser::CStateItem> *m_Agenda;
../../../../common/depparser/implementations/emnlp08/depparser.h:      m_Agenda = new CAgendaBeam<depparser::CStateItem>(depparser::AGENDA_SIZE);
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline depparser::SCORE_TYPE getOrUpdateStackScore( const depparser::CStateItem *item, const unsigned long &action, depparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/depparser/implementations/emnlp08/depparser.h:   void updateScoresForStates( const depparser::CStateItem *outout , const depparser::CStateItem *correct , 
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void updateScoreForState( const depparser::CStateItem *outout , const depparser::SCORE_TYPE &amount ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void reduce( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void shift( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void arcleft( depparser::CStateItem *item, const unsigned long &label ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void arcright( depparser::CStateItem *item, const unsigned long &label ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void arcleft( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void arcright( depparser::CStateItem *item ) ;
../../../../common/depparser/implementations/emnlp08/depparser.h:   inline void poproot( depparser::CStateItem *item ) ;  
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline SCORE_TYPE CDepParser::getOrUpdateStackScore( const CStateItem *item, const unsigned long &action, SCORE_TYPE amount , int round ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   static CStateItem item, temp;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      switch ( CStateItem::getAction(action) ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      case CStateItem::SHIFT:
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      case CStateItem::REDUCE:
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      case CStateItem::ARC_LEFT:
../../../../common/depparser/implementations/emnlp08/depparser.cpp:         arcleft( &temp, CStateItem::getLabel(action) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      case CStateItem::ARC_RIGHT:
../../../../common/depparser/implementations/emnlp08/depparser.cpp:         arcright( &temp, CStateItem::getLabel(action) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      case CStateItem::POP_ROOT:
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline int find_information( const CStateItem *item, int *stack ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      stack[i] = CStateItem::OFF_STACK;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_SHIFT;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:         stack[item->stackitem(i)] = CStateItem::ON_STACK_ARCRIGHT;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   CStateItem state;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::updateScoreForState( const CStateItem *outout , const SCORE_TYPE &amount ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:         if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      if ( outout_stackstatus[i] == CStateItem::OFF_STACK ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   static CStateItem item;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      if ( CStateItem::getAction(action) != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:      if ( action != CStateItem::POP_ROOT ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:         if ( CStateItem::getLabel(action) )
../../../../common/depparser/implementations/emnlp08/depparser.cpp:            getOrUpdateStackScore( &item, CStateItem::removeLabelFromEncodedAction(action), amount, m_nTrainingRound );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:void CDepParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct , SCORE_TYPE amount_add, SCORE_TYPE amount_subtract ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::reduce( CStateItem *item ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::REDUCE, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::REDUCE );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item, const unsigned long &label ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::arcleft( CStateItem *item ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_LEFT, label) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_LEFT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_LEFT );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::arcright( CStateItem *item, const unsigned long &label ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::arcright( CStateItem *item ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_RIGHT, label) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::ARC_RIGHT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::ARC_RIGHT );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::shift( CStateItem *item ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::encodeAction(CStateItem::SHIFT, CDependencyLabel::NONE) );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   item->stackscore() += getOrUpdateStackScore( item, CStateItem::SHIFT );
../../../../common/depparser/implementations/emnlp08/depparser.cpp:inline void CDepParser::poproot( CStateItem *item ) {
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   const CStateItem *pGenerator ;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   static CStateItem pCandidate ;
../../../../common/depparser/implementations/emnlp08/depparser.cpp:   static CStateItem correctState ;
../../../../common/tagger/implementations/agenda/tagger_stateitem.h: * CStateItem - the search state item, representing a tagged sentence 
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:struct CStateItem {
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:   const CStateItem *prev;
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:   CStateItem() : prev(0), tag() { }
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:   CStateItem(CStateItem& item) { THROW("CStateItem does not support copy constructor!"); }
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->m_nScore < item.m_nScore; }
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->m_nScore > item.m_nScore; }
../../../../common/tagger/implementations/agenda/tagger_stateitem.h:   inline void operator = (const CStateItem &item) {
../../../../common/tagger/implementations/agenda/tagger.cpp:TARGET_LANGUAGE::tagger::SCORE_TYPE TARGET_LANGUAGE::CTagger::getLocalScore( CStringVector * sentence, CStateItem * item , unsigned long int index ) {
../../../../common/tagger/implementations/agenda/tagger.cpp:   const CStateItem *pGenerator;
../../../../common/tagger/implementations/agenda/tagger.cpp:   static CStateItem best_bigram[1<<CTag::SIZE][1<<CTag::SIZE];
../../../../common/tagger/implementations/agenda/tagger.cpp:   static CStateItem stateitems[AGENDA_SIZE*MAX_SENTENCE_SIZE];
../../../../common/tagger/implementations/agenda/tagger.cpp:   static CStateItem temp;
../../../../common/tagger/implementations/agenda/tagger_impl.h:class CStateItem;
../../../../common/tagger/implementations/agenda/tagger_impl.h:      CAgendaSimple<CStateItem> *m_Agenda;
../../../../common/tagger/implementations/agenda/tagger_impl.h:      CTaggerImpl() { m_Agenda = new CAgendaSimple<CStateItem>(AGENDA_SIZE); }
../../../../common/tagger/implementations/agenda/tagger.h:  inline tagger::SCORE_TYPE getGlobalScore(CStringVector* sentence, tagger::CStateItem* item);
../../../../common/tagger/implementations/agenda/tagger.h:  inline tagger::SCORE_TYPE getLocalScore(CStringVector* sentence, tagger::CStateItem* item, unsigned long int index);
../../../../common/tagger/implementations/collins/tagger_stateitem.h: * CStateItem - the search state item, representing a tagged sentence 
../../../../common/tagger/implementations/collins/tagger_stateitem.h:struct CStateItem {
../../../../common/tagger/implementations/collins/tagger_stateitem.h:   const CStateItem *prev;
../../../../common/tagger/implementations/collins/tagger_stateitem.h:   CStateItem() : prev(0), tag() { }
../../../../common/tagger/implementations/collins/tagger_stateitem.h:   CStateItem(CStateItem& item) { THROW("CStateItem does not support copy constructor!"); }
../../../../common/tagger/implementations/collins/tagger_stateitem.h:   inline bool operator < (const CStateItem &item) const { return this->m_nScore < item.m_nScore; }
../../../../common/tagger/implementations/collins/tagger_stateitem.h:   inline bool operator > (const CStateItem &item) const { return this->m_nScore > item.m_nScore; }
../../../../common/tagger/implementations/collins/tagger_stateitem.h:   inline void operator = (const CStateItem &item) {
../../../../common/tagger/implementations/collins/tagger.cpp:void TARGET_LANGUAGE::CTagger::getLocalScore( CPackedScoreType<SCORE_TYPE, CTag::MAX_COUNT> &retval, const CStringVector *sentence, const CStateItem *item , const unsigned long &index ) {
../../../../common/tagger/implementations/collins/tagger.cpp:   const CStateItem *pGenerator;
../../../../common/tagger/implementations/collins/tagger.cpp:   static CStateItem best_bigram[1<<CTag::SIZE][1<<CTag::SIZE];
../../../../common/tagger/implementations/collins/tagger.cpp:   static CStateItem temp;
../../../../common/tagger/implementations/collins/tagger.cpp:      stateitems = new CStateItem[AGENDA_SIZE*m_nMaxSentenceSize];
../../../../common/tagger/implementations/collins/tagger_impl.h:class CStateItem;
../../../../common/tagger/implementations/collins/tagger_impl.h:      CAgendaSimple<CStateItem> *m_Agenda;
../../../../common/tagger/implementations/collins/tagger_impl.h:      CTaggerImpl() { m_Agenda = new CAgendaSimple<CStateItem>(AGENDA_SIZE); }
../../../../common/tagger/implementations/collins/tagger.h:   tagger::CStateItem *stateitems;
../../../../common/tagger/implementations/collins/tagger.h:      stateitems = new tagger::CStateItem[tagger::AGENDA_SIZE*m_nMaxSentenceSize];
../../../../common/tagger/implementations/collins/tagger.h:  inline void getLocalScore(CPackedScoreType<tagger::SCORE_TYPE, CTag::MAX_COUNT> &retval, const CStringVector* sentence, const tagger::CStateItem* item, const unsigned long &index);
../../../../common/conparser/implementations/srnew/rule.h:   void getActions(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srnew/rule.h:   void getShiftRules(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srnew/rule.h:   void getBinaryRules(const CStateItem &item,  std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srnew/rule.h:   void getUnaryRules(const CStateItem &item,  std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srnew/conparser.h://   CAgendaBeam<conparser::CStateItem> *m_Agenda;
../../../../common/conparser/implementations/srnew/conparser.h://      m_Agenda = new CAgendaBeam<conparser::CStateItem>(conparser::AGENDA_SIZE);
../../../../common/conparser/implementations/srnew/conparser.h:   inline conparser::SCORE_TYPE getOrUpdateGraphScore( const conparser::CStateItem *item, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/srnew/conparser.h:   inline conparser::SCORE_TYPE getOrUpdateStackScore( const conparser::CStateItem *item, const conparser::CAction &action, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/srnew/conparser.h:   inline conparser::SCORE_TYPE getOrUpdateScore( const conparser::CStateItem &item, const conparser::CAction &action, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/srnew/conparser.h:   void updateScoresForStates( const conparser::CStateItem *outout , const conparser::CStateItem *correct ) ;
../../../../common/conparser/implementations/srnew/conparser.h:   void updateScoresForState( const conparser::CStateItem *outout , SCORE_UPDATE update ) ;
../../../../common/conparser/implementations/srnew/context.h:class CStateItem;
../../../../common/conparser/implementations/srnew/context.h:   void load(const CStateItem *item, const std::vector<CTaggedWord<CTag, TAG_SEPARATOR> > &wrds, const std::vector<unsigned long> &wordlen, const bool &modify) {
../../../../common/conparser/implementations/srnew/stateitem.h: * CStateItem - the search state item, representing a partial
../../../../common/conparser/implementations/srnew/stateitem.h:class CStateItem {
../../../../common/conparser/implementations/srnew/stateitem.h:   const CStateItem *statePtr;
../../../../common/conparser/implementations/srnew/stateitem.h:   const CStateItem *stackPtr;
../../../../common/conparser/implementations/srnew/stateitem.h:   CStateItem() : current_word(0), score(0), action(), /*sent(0),*/ stackPtr(0), statePtr(0), node() {}
../../../../common/conparser/implementations/srnew/stateitem.h:   virtual ~CStateItem() {}
../../../../common/conparser/implementations/srnew/stateitem.h:      const CStateItem *current = this;
../../../../common/conparser/implementations/srnew/stateitem.h:      const CStateItem *current = this;
../../../../common/conparser/implementations/srnew/stateitem.h:   bool operator < (const CStateItem &st) const { return score < st.score; }
../../../../common/conparser/implementations/srnew/stateitem.h:   bool operator > (const CStateItem &st) const { return score > st.score; }
../../../../common/conparser/implementations/srnew/stateitem.h:   bool operator == (const CStateItem &st) const {
../../../../common/conparser/implementations/srnew/stateitem.h:   bool operator != (const CStateItem &st) const { return !( (*this) == st ); }
../../../../common/conparser/implementations/srnew/stateitem.h:   void shift(CStateItem *retval, const unsigned long &constituent = CConstituent::NONE) const {
../../../../common/conparser/implementations/srnew/stateitem.h:   void reduce(CStateItem *retval, const unsigned long &constituent, const bool &single_child, const bool &head_left, const bool &temporary) const {
../../../../common/conparser/implementations/srnew/stateitem.h:   void terminate(CStateItem *retval) const {
../../../../common/conparser/implementations/srnew/stateitem.h:   void Move(CStateItem *retval, const CAction &action) const {
../../../../common/conparser/implementations/srnew/stateitem.h:         static const CStateItem *item;
../../../../common/conparser/implementations/srnew/stateitem.h:         static CStateItem *tmp;
../../../../common/conparser/implementations/srnew/stateitem.h:         tmp = new CStateItem[stacksize()];
../../../../common/conparser/implementations/srnew/stateitem.h:         static CStateItem *current;
../../../../common/conparser/implementations/srnew/stateitem.h:      const static CStateItem *current;
../../../../common/conparser/implementations/srnew/stateitem.h:      static const CStateItem* states[MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2];
../../../../common/conparser/implementations/srnew/stateitem.h:      const static CStateItem *current;
../../../../common/conparser/implementations/srnew/stateitem.h:   const CStateItem *item;
../../../../common/conparser/implementations/srnew/stateitem.h:   void load(const CAction &action, const CStateItem *item, const SCORE_TYPE &score) {
../../../../common/conparser/implementations/srnew/conparser.cpp:SCORE_TYPE CConParser::getOrUpdateGraphScore( const CStateItem *item, SCORE_TYPE amount, int round ) {
../../../../common/conparser/implementations/srnew/conparser.cpp:inline SCORE_TYPE CConParser::getOrUpdateStackScore( const CStateItem *item, const CAction &action, SCORE_TYPE amount , int round ) {
../../../../common/conparser/implementations/srnew/conparser.cpp:void CConParser::updateScoresForState( const CStateItem *item , const SCORE_UPDATE update ) {
../../../../common/conparser/implementations/srnew/conparser.cpp:   const static CStateItem* states[MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2];
../../../../common/conparser/implementations/srnew/conparser.cpp:   const CStateItem *current;
../../../../common/conparser/implementations/srnew/conparser.cpp:void CConParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct ) {
../../../../common/conparser/implementations/srnew/conparser.cpp:SCORE_TYPE CConParser::getOrUpdateScore( const conparser::CStateItem &item, const conparser::CAction &action, conparser::SCORE_TYPE amount, int round ) {
../../../../common/conparser/implementations/srnew/conparser.cpp:   static CStateItem lattice[(MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2)*AGENDA_SIZE];
../../../../common/conparser/implementations/srnew/conparser.cpp:   static CStateItem *lattice_index[MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2];
../../../../common/conparser/implementations/srnew/conparser.cpp:   const static CStateItem *pGenerator ;
../../../../common/conparser/implementations/srnew/conparser.cpp:   const static CStateItem *pBestGen;
../../../../common/conparser/implementations/srnew/conparser.cpp:   const static CStateItem *correctState ;
../../../../common/conparser/implementations/srnew/conparser.cpp:   const static CStateItem *candidate_outout;
../../../../common/conparser/implementations/srold/rule.h:   void getActions(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srold/rule.h:   void getShiftRules(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srold/rule.h:   void getBinaryRules(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srold/rule.h:   void getUnaryRules(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/srold/conparser.h:   CAgendaBeam<conparser::CStateItem> *m_Agenda;
../../../../common/conparser/implementations/srold/conparser.h:      m_Agenda = new CAgendaBeam<conparser::CStateItem>(conparser::AGENDA_SIZE);
../../../../common/conparser/implementations/srold/conparser.h:   inline conparser::SCORE_TYPE getOrUpdateGraphScore( const conparser::CStateItem *item, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/srold/conparser.h:   inline conparser::SCORE_TYPE getOrUpdateStackScore( const conparser::CStateItem *item, const conparser::CAction &action, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/srold/conparser.h:   inline conparser::SCORE_TYPE getOrUpdateScore( const conparser::CStateItem &item, const conparser::CAction &action, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/srold/conparser.h:   void updateScoresForStates( const conparser::CStateItem *outout , const conparser::CStateItem *correct ) ;
../../../../common/conparser/implementations/srold/conparser.h:   void updateScoresForState( const conparser::CStateItem *outout , SCORE_UPDATE update ) ;
../../../../common/conparser/implementations/srold/context.h:class CStateItem;
../../../../common/conparser/implementations/srold/context.h:   void load(const CStateItem *item, const std::vector<CTaggedWord<CTag, TAG_SEPARATOR> > &wrds, const std::vector<unsigned long> &wordlen, const bool &modify) {
../../../../common/conparser/implementations/srold/stateitem.h: * CStateItem - the search state item, representing a partial
../../../../common/conparser/implementations/srold/stateitem.h:class CStateItem {
../../../../common/conparser/implementations/srold/stateitem.h:   CStateItem() : current_word(0), score(0), unary_reduce(0), context(0), sent(0), stack(), nodes() {}
../../../../common/conparser/implementations/srold/stateitem.h:   virtual ~CStateItem() {}
../../../../common/conparser/implementations/srold/stateitem.h:   bool operator < (const CStateItem &st) const { return score < st.score; }
../../../../common/conparser/implementations/srold/stateitem.h:   bool operator > (const CStateItem &st) const { return score > st.score; }
../../../../common/conparser/implementations/srold/stateitem.h:   bool operator == (const CStateItem &st) const {
../../../../common/conparser/implementations/srold/stateitem.h:   bool operator != (const CStateItem &st) const { return !( (*this) == st ); }
../../../../common/conparser/implementations/srold/stateitem.h:   void operator = (const CStateItem &st) { current_word=st.current_word; unary_reduce=st.unary_reduce; nodes=st.nodes; stack=st.stack; score=st.score; sent = st.sent; }
../../../../common/conparser/implementations/srold/stateitem.h:   void NextMove(const CStateItem &snt, CAction &retval) const {
../../../../common/conparser/implementations/srold/stateitem.h:   void FollowMove(const CStateItem &st, CAction &retval) const {
../../../../common/conparser/implementations/srold/stateitem.h:         static CStateItem item;
../../../../common/conparser/implementations/srold/stateitem.h:      CStateItem st; 
../../../../common/conparser/implementations/srold/conparser.cpp:SCORE_TYPE CConParser::getOrUpdateGraphScore( const CStateItem *item, SCORE_TYPE amount, int round ) {
../../../../common/conparser/implementations/srold/conparser.cpp:inline SCORE_TYPE CConParser::getOrUpdateStackScore( const CStateItem *item, const CAction &action, SCORE_TYPE amount , int round ) {
../../../../common/conparser/implementations/srold/conparser.cpp:void CConParser::updateScoresForState( const CStateItem *item , const SCORE_UPDATE update ) {
../../../../common/conparser/implementations/srold/conparser.cpp:   static CStateItem st;
../../../../common/conparser/implementations/srold/conparser.cpp:void CConParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct ) {
../../../../common/conparser/implementations/srold/conparser.cpp:SCORE_TYPE CConParser::getOrUpdateScore( const conparser::CStateItem &item, const conparser::CAction &action, conparser::SCORE_TYPE amount, int round ) {
../../../../common/conparser/implementations/srold/conparser.cpp:   const static CStateItem *pGenerator ;
../../../../common/conparser/implementations/srold/conparser.cpp:   static CStateItem oCandidate ;
../../../../common/conparser/implementations/srold/conparser.cpp:   static CStateItem correctState ;
../../../../common/conparser/implementations/srold/conparser.cpp:   const static CStateItem *pBestGen;
../../../../common/conparser/implementations/srold/conparser.cpp:   static CStateItem candidate_outout;
../../../../common/conparser/implementations/sr/rule.h:   void getActions(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/sr/rule.h:   void getShiftRules(const CStateItem &item, std::vector<CAction> &actions) {
../../../../common/conparser/implementations/sr/rule.h:   void getBinaryRules(const CStateItem &item,  std::vector<CAction> &actions) {
../../../../common/conparser/implementations/sr/rule.h:   void getUnaryRules(const CStateItem &item,  std::vector<CAction> &actions) {
../../../../common/conparser/implementations/sr/conparser.h://   CAgendaBeam<conparser::CStateItem> *m_Agenda;
../../../../common/conparser/implementations/sr/conparser.h://      m_Agenda = new CAgendaBeam<conparser::CStateItem>(conparser::AGENDA_SIZE);
../../../../common/conparser/implementations/sr/conparser.h:   inline void getOrUpdateStackScore( CPackedScoreType<conparser::SCORE_TYPE, conparser::CAction::MAX> &retval, const conparser::CStateItem *item, const conparser::CAction &action, conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/sr/conparser.h:   inline void getOrUpdateScore( CPackedScoreType<conparser::SCORE_TYPE, conparser::CAction::MAX> &retval, const conparser::CStateItem &item, const conparser::CAction &action=conparser::CAction(), conparser::SCORE_TYPE amount=0, int round=0 );
../../../../common/conparser/implementations/sr/conparser.h:   void updateScoresForStates( const conparser::CStateItem *outout , const conparser::CStateItem *correct ) ;
../../../../common/conparser/implementations/sr/conparser.h:   void updateScoresForState( const conparser::CStateItem *outout , SCORE_UPDATE update ) ;
../../../../common/conparser/implementations/sr/context.h:class CStateItem;
../../../../common/conparser/implementations/sr/context.h:   void load(const CStateItem *item, const std::vector<CTaggedWord<CTag, TAG_SEPARATOR> > &wrds, const std::vector<unsigned long> &wordlen, const bool &modify) {
../../../../common/conparser/implementations/sr/stateitem.h: * CStateItem - the search state item, representing a partial
../../../../common/conparser/implementations/sr/stateitem.h:class CStateItem {
../../../../common/conparser/implementations/sr/stateitem.h:   const CStateItem *statePtr;
../../../../common/conparser/implementations/sr/stateitem.h:   const CStateItem *stackPtr;
../../../../common/conparser/implementations/sr/stateitem.h:   CStateItem() : current_word(0), score(0), action(), /*sent(0),*/ stackPtr(0), statePtr(0), node() {}
../../../../common/conparser/implementations/sr/stateitem.h:   virtual ~CStateItem() {}
../../../../common/conparser/implementations/sr/stateitem.h:      const CStateItem *current = this;
../../../../common/conparser/implementations/sr/stateitem.h:      const CStateItem *current = this;
../../../../common/conparser/implementations/sr/stateitem.h:   bool operator < (const CStateItem &st) const { return score < st.score; }
../../../../common/conparser/implementations/sr/stateitem.h:   bool operator > (const CStateItem &st) const { return score > st.score; }
../../../../common/conparser/implementations/sr/stateitem.h:   bool operator == (const CStateItem &st) const {
../../../../common/conparser/implementations/sr/stateitem.h:   bool operator != (const CStateItem &st) const { return !( (*this) == st ); }
../../../../common/conparser/implementations/sr/stateitem.h:   void shift(CStateItem *retval, const unsigned long &constituent = CConstituent::NONE) const {
../../../../common/conparser/implementations/sr/stateitem.h:   void reduce(CStateItem *retval, const unsigned long &constituent, const bool &single_child, const bool &head_left, const bool &temporary) const {
../../../../common/conparser/implementations/sr/stateitem.h:   void terminate(CStateItem *retval) const {
../../../../common/conparser/implementations/sr/stateitem.h:   void Move(CStateItem *retval, const CAction &action) const {
../../../../common/conparser/implementations/sr/stateitem.h:         static const CStateItem *item;
../../../../common/conparser/implementations/sr/stateitem.h:         static CStateItem *tmp;
../../../../common/conparser/implementations/sr/stateitem.h:         tmp = new CStateItem[stacksize()];
../../../../common/conparser/implementations/sr/stateitem.h:         static CStateItem *current;
../../../../common/conparser/implementations/sr/stateitem.h:      const static CStateItem *current;
../../../../common/conparser/implementations/sr/stateitem.h:      static const CStateItem* states[MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2];
../../../../common/conparser/implementations/sr/stateitem.h:      const static CStateItem *current;
../../../../common/conparser/implementations/sr/stateitem.h:   const CStateItem *item;
../../../../common/conparser/implementations/sr/stateitem.h:   void load(const CAction &action, const CStateItem *item, const SCORE_TYPE &score) {
../../../../common/conparser/implementations/sr/conparser.cpp:inline void CConParser::getOrUpdateStackScore( CPackedScoreType<SCORE_TYPE, CAction::MAX> &retval, const CStateItem *item, const CAction &action, SCORE_TYPE amount , int round ) {
../../../../common/conparser/implementations/sr/conparser.cpp:void CConParser::updateScoresForState( const CStateItem *item , const SCORE_UPDATE update ) {
../../../../common/conparser/implementations/sr/conparser.cpp:   const static CStateItem* states[MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2];
../../../../common/conparser/implementations/sr/conparser.cpp:   const CStateItem *current;
../../../../common/conparser/implementations/sr/conparser.cpp:void CConParser::updateScoresForStates( const CStateItem *outout , const CStateItem *correct ) {
../../../../common/conparser/implementations/sr/conparser.cpp:void CConParser::getOrUpdateScore( CPackedScoreType<SCORE_TYPE, CAction::MAX> &retval, const conparser::CStateItem &item, const conparser::CAction &action, conparser::SCORE_TYPE amount, int round ) {
../../../../common/conparser/implementations/sr/conparser.cpp:   static CStateItem lattice[(MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2)*AGENDA_SIZE];
../../../../common/conparser/implementations/sr/conparser.cpp:   static CStateItem *lattice_index[MAX_SENTENCE_SIZE*(2+UNARY_MOVES)+2];
../../../../common/conparser/implementations/sr/conparser.cpp:   const static CStateItem *pGenerator ;
../../../../common/conparser/implementations/sr/conparser.cpp:   const static CStateItem *pBestGen;
../../../../common/conparser/implementations/sr/conparser.cpp:   const static CStateItem *correctState ;
../../../../common/conparser/implementations/sr/conparser.cpp:   const static CStateItem *candidate_outout;
../../../../common/conparser/implementations/sr/conparser.cpp:   static CStateItem state[MAX_SENTENCE_SIZE*(1+UNARY_MOVES)+2];
